{"meta":{"title":"Lemony Blog","subtitle":"凝萌的小窝","description":null,"author":"LemonyNingmeng","url":"https://NingmengLemon.github.io","root":"/"},"pages":[{"title":"","date":"2023-12-28T04:32:15.894Z","updated":"2023-12-28T04:32:15.894Z","comments":true,"path":"custom.css","permalink":"https://ningmenglemon.github.io/custom.css","excerpt":"","text":":root { --gutter: 25px; --radius: 13px; --color-primary: #66ccff; --color2: #35c9bb; --color3: #ffb900; --color4: #33d57a; --color5: #00dbff; --color6: #1a98ff; --color7: #9090ff; --color-primary-bg: rgba(102, 204, 255, 0.15); --color2-bg: rgba(53, 201, 187, 0.15); --color3-bg: rgba(255,185,0,0.15); --color4-bg: rgba(51,213,122,0.15); --color5-bg: rgba(0,219,255,0.15); --color6-bg: rgba(26,152,255,0.15); --color7-bg: rgba(144,144,255,0.15); --color-shadow: rgba(161, 177, 204, 0.4); }"},{"title":"文章归档","date":"2023-12-27T13:29:47.459Z","updated":"2023-12-27T13:28:23.464Z","comments":true,"path":"archive.html","permalink":"https://ningmenglemon.github.io/archive.html","excerpt":"","text":""},{"title":"朋友们","date":"2023-12-28T07:30:03.571Z","updated":"2023-12-28T07:30:03.571Z","comments":true,"path":"friends.html","permalink":"https://ningmenglemon.github.io/friends.html","excerpt":"","text":"朋友们"},{"title":"关于","date":"2023-12-27T16:00:00.000Z","updated":"2023-12-28T06:47:48.574Z","comments":true,"path":"about.html","permalink":"https://ningmenglemon.github.io/about.html","excerpt":"","text":"18 岁，事个沙贝 Nice to meet you ( •̀ ω •́ )✧ 咱目前就读于杭州电子科技高等专科学校大学 是数学苦手、编程苦手和社交苦手 头像来源"}],"posts":[{"title":"尝试介绍一下我的 Mirai 酱","slug":"Try-to-introduce-my-MiraiChan","date":"2024-02-08T02:00:00.000Z","updated":"2024-02-08T11:01:28.372Z","comments":true,"path":"2024/02/08/Try-to-introduce-my-MiraiChan/","permalink":"https://ningmenglemon.github.io/2024/02/08/Try-to-introduce-my-MiraiChan/","excerpt":"","text":"首先很抱歉先前那篇讲 BiliTools 的文章不更了，问就是太烂了讲不动一点这次我想来讲一下我的 QQ 机器人，Mirai 酱 Mirai 酱的故事最初想要做一个自己的 QQ 机器人，应该是在某位群友在群里询问了关于机器人的事之后。后来他拉着他的机器人凯尔希进了群，不过不知为何最后却似了。 最初的 Mirai 酱翻了下我的程序存档，Mirai 酱最早是在 2022 年 4 月左右被我编写出来的，当时基于Ariadne和mirai。 Mirai 酱之所以叫 Mirai 酱，正是因为她最开始基于的框架是mirai （绝对不是因为我是个起名废物qwq） 这是 Mirai 酱的第一代，拥有 B站动态转发、随机涩图、天气查询、每日抽签 功能。（其实当然可以写更多，只是我没点子了） 后来不知道什么时候，mirai框架似了，Mirai 酱也被我忘记了一段时间。直到……go-cqhttp框架的出现。 在找引用链接的时候我发现mirai框架居然还活着，而且社区也跟进了签名服务器插件的开发（但框架转了就是转了，也没有转回去这种说法了） 重生的 Mirai 酱Mirai 酱第二代的完成大约是在 2023 年 6 月 12 日左右，基于pycqBot和go-cqhttp。在 8 月 24 日左右追加了unidbg-fetch-qsign来进行签名认证。这一代的 Mirai 酱功能没有增加，甚至还减少了一个天气查询功能。（天气查询真没人用罢，交互还难写）不过群友们在 Mirai 酱复活赛打赢之后还是很高兴，甚至发起了电 现在的 Mirai 酱Mirai 酱第三代的大致完成大致是在 2024 年 2 月 8 日零点左右这一代的 Mirai 酱新增了方舟模拟抽卡的插件，并且每个插件都可以单独为某个群开启或关闭。 这次的框架迁移是因为go-cqhttp的停止维护（详见：QQBot的未来以及迁移建议）。尽管 Mirai 酱还没因为这个出现什么问题，我还是根据他们的建议将 Mirai 酱迁移到了OpenShamrock框架。 然后我就发现虽然go-cqhttp和shamrock都是遵循onebot标准的，但是pycqBot在与shamrock交互的时候始终有莫名其妙的问题。于是我就仿照pycqBot专门为shamrock写了一个简易框架（有直接使用pycqBot中的一些代码，比如cqcode的实现），已经能够满足 Mirai 酱的需求了。不过因为实在是太简易了，以至于插件写起来与pycqBot相比有亿点麻烦（恼）emm 就当作是 Python 练习了罢（？）：你说得对，但是这就是重复造轮子的沙贝操作（全恼） shamrock被我部署在了我的小主机上的 PVE 里，依靠BlissOS运行。（参考：PVE下安装BlissOS11） 因为 tx 的作品实在是太“精致”了，为了 QQ 能够比较稳定地运行，我不得不给 BlissOS 开了 6GB 的 RAM 主要的 Python 程序被我部署在了 PVE 中的另一台 Debian 12 上 目前挂了一天一夜还没有出问题 关于简易框架 十分甚至九分感谢pycqBot项目，提供了思路和具体实现供我照搬参考 所以说这个简易框架，应该算是mini-pycqBot？（大雾） 通信方式和pycqBot一样，都是 用websocket接收框架的事件上报 用http发送指令到框架 各部分关系12345678910111213lemonyBot:- __init__.py- base.py: # 通信基础 - SocketBase # 提供 WebSocket 通信方法 - HttpBase # 提供 HTTP 通信方法- apps.py: - SocketApp # 封装了消息上报的接收（基本抄自 pycqBot） - HttpApp # 封装了接口（基本抄自 shamrock 文档）- bot.py: - Bot # 将 ws 和 http 部分结合到一起- objects.py: - Plugin # 插件对象的父类- cqcode.py # 照搬自 pycqBot flowchart LR SocketBase --> SocketApp --> Bot HttpBase --> HttpApp --> Bot Plugin 插件系统的实现使用Bot.load_plugin()加载一个插件实例之后，这个实例会被保存在Bot._plugins列表中 每当SocketApp收到消息上报时，它会根据消息的类型挨个去尝试调用插件们的对应方法，如果插件定义了对应的方法，它就会把消息包传给这个方法。（消息类型的名字的生成照抄了pycqBot） 当插件想要发送指令时，它只需要调用自身对应名字的方法即可。这些方法在Plugin父类中被批量预先定义（且分为普通和异步版本）这些方法对Bot.call_api()进行了封装，这样他们就只需要传入参数，而不用传入方法名了 如何使用老实说，真的会有人来用这个框架吗……就当是写给自己看的了，免得以后想搓新插件的时候又忘了 简单的使用入口模块至少应该长这个样子： 1234567891011121314151617# 框架主体应当被最先导入import lemonyBot# 导入各个插件类from plugins.MyPlugin import MyPlugin# 实例化Bot，记得改成自己的参数bot = lemonyBot.Bot(**&#123; &quot;ws_host&quot;: &quot;127.0.0.1:1145&quot;, &quot;http_host&quot;: &quot;127.0.0.1:1919&quot;, &quot;authkey&quot;: &quot;aughhhhhhhhhhhhhh&quot;,&#125;)# 设置管理员QQ号（选）bot.set_config(admins=[114514])# 挨个加载插件（的实例）bot.load_plugin(MyPlugin(bot))# 启动bot.start() 连我自己都觉得麻烦了往后可能会优化一下导入方法，写成像pycqBot那样的： 123bot.plugin_load([ &quot;MyPlugin&quot; ]) 真的方便吧我靠 再看看我这个简直就是原神 上面设置的管理员不同于群里的管理员，而是 Bot 的管理员。插件可以通过这个来校验一些只有 Bot 主人才能有的权限。（当然一个插件里都没写的话这个东西也就没用了） 插件开发一个插件至少应该长这个样子： 12345678910111213141516171819202122232425262728293031323334353637# 导入必需的模板from lemonyBot import Plugin, cqcode, Bot# 定义插件类，父类必须为 Pluginclass MyPlugin(Plugin): def __init__(self, bot: Bot): super().__init__(bot) self.bot: Bot # 在这后面加一些自己的初始化操作比如加载涩图数据 # 定义用于接受上报事件的方法，参数为一个 dict # 在 bot 收到这个类型的消息时会被自动调用 # event 的详细内容自己去查 shamrock 之类的文档 def message_group_normal(self, event: dict): # 在这里写对消息事件的处理，比如回复一个 Hello if event[&quot;message&quot;].lower().strip() == &quot;ciallo&quot;: # 调用预定义的方法，这里是普通版，没有返回值 # 要检查消息的发送结果请使用异步版方法 # ↑ 比如：self.send_group_msg_func_async() # 异步版的返回值自己去查对应文档 # 方法只接受一个字典参数，以后可能会加一个 **kwargs 调用方法 self.send_group_msg_func( # 这个字典的键值就是接口的参数 # 具体参数需要你去查 shamrock 之类的文档 &#123; &quot;group_id&quot;: event[&quot;group_id&quot;], # 使用 cqcode 添加各种特殊消息 比如回复、图片 # cqcode 模块的使用方法详见 pycqBot 的文档 # 关于 cqcode 可以去看 go-cqhttp 文档 # ↑ https://docs.go-cqhttp.org/cqcode/ # cqcode 是字符串，可以直接与正文拼接 &quot;message&quot;: cqcode.reply(msg_id=event[&quot;message_id&quot;]) + &quot;Ciallo～(∠・ω&lt; )⌒☆&quot;, &quot;auto_escape&quot;: False, &#125; ) # 达到了对群里发出的每一条 ciallo 都回复一个 Ciallo～(∠・ω&lt; )⌒☆ 的效果 普通版方法和异步版方法的名字只差一个后缀，是_func还是_async可以使用self.bot.add_task()来借助简易框架内置的给aiohttp用的事件循环运行自己的协程（异步自己去学，我讲不清楚的w） 通过self.admins可以得到 Bot 的管理员们的QQ，以此来实现鉴权之类的操作插件有需要网络请求的部分可以搞依赖注入，来使用self.bot.request这个写好的网络请求 缺陷如你所见，这个简易框架： 没有定义消息类之类的简化处理流程之类的东西，而是直接让开发者处理事件字典 没有把接口的参数之类的写到程序里，而是要你自己去查文档 没有快捷的回复功能，必须自己手动生成cqcode来加到回复消息里（应该算是第一条的一部分） 没有像这个一样的方便的消息筛选系统、鉴权系统，全都要开发者自己写 还有很多…… 笑嘻了，我消息筛选用正则表达式用到似 总之就是非常的简陋就是了，你要什么得自己来，一点都不开箱即用。 不过反正都是自用的就是了 我怎么写也没人能管我（小声） 关于 Mirai 酱的插件们涩图插件插件名：EroPicSender 运行逻辑 flowchart TB askforsetu[/群友找Mirai酱要涩图/] --> checkperm checkperm{检查插件开关} -- 关 -->reject reject[拒绝] checkperm -- 开 --> checkcd checkcd{检查冷却时间} -- 到了 --> getsetudata checkcd -- 没到 --> reject getsetudata[获得涩图数据] --> download[下载涩图本体] --> checktag checktag{检查涩图标签\\n（R18之类的）} -- 能发 --> sendwithimg[发送图片] --> withdraw sendwithimg --> checkassets checktag -- 不能发 --> sendwithoutimg[仅发送文字描述] --> checkassets withdraw[等待1分钟后撤回涩图] cache[(涩图缓存)] -.-> getsetudata checkassets{检查涩图缓存} -- 不足 --> 获取一包新的涩图 -.-> cache checkassets -- 充足 --> over[什么都不做] checkassets -.- cache init[/插件初始化/] --> loadcache loadcache[从文件加载保存的缓存] --> checkassets loadcache -.-> cache （尝试用 mermaid 做了流程图，但是一坨） 管理员可以无视插件开关要涩图 涩图下载失败也会发送提示 涩图发送失败会改为仅发送文字描述 程序退出时会保存缓存到文件 图源来自 Lolicon API，非常感谢它的开发者 明日方舟抽卡模拟插件名：ArknightsGacha 数据获取干员列表来自 BiliGame Wiki把获取的网页用 xpath 一翻，数据就来了 什么？为什么不是 PRTS ？ 因为 B 站他直接把数据丢网页源代码里了，大好人属于是 根据干员的获取途径生成中坚和常驻两个池子限定池子理论上也能做，但是群友急了于是先这样了 能够通过指令让 Mirai 酱立即更新干员数据 运行逻辑插件初始化时会从本地加载保存的干员数据加载完毕后生成两个字典（代表中坚和标准两个池子），键为星级，值为对应的干员列表 每次请求抽卡时定义一个初始概率表： 123456&#123; 3: 0.4, 4: 0.5, 5: 0.08, 6: 0.02,&#125; 很明显 键是星级，值是概率 抽卡会传入一个combo值，代表连续抽了多少抽没出 6 星。这个值可以经由群员的QQ号查到，用以实现 “若连续 50 发未出 6 星，下次 6 星概率增加 2%，直到第 100 发时必出 6 星” 的设定抽卡函数会根据上述逻辑对初始概率表进行修改，然后通过带权重的随机来确定抽到的星级，最后用初始化时生成的字典来得到具体抽到的干员数据，返回给负责交互的部分 combo值由负责交互的那一坨保管，每当抽到 6 星时这个值就重设为0在收到干员数据之后负责交互的那部分便生成文本，回复给群友 B 站动态转发插件名：BiliDynamicForwarder 运行逻辑每 5 分钟请求一遍监听对象们的历史动态，与上一次请求的数据比对，找出新发布的进行发送↑ emm我的“找出新发布的动态”这个部分似乎还有点问题，时不时就会把历史的某一条动态刨出来发了 如果动态内容命中了黑关键词，那么它将不会被发送；但是如果同时又命中了白关键词，那么它还是会被发送。 这个插件的交互部分主要就是设置监听对象，逻辑还挺简单的，难写的原因是没有现成的鉴权和指令系统其余部分都是主动发送了没什么好说的 自动维护一个用 B 站 uid 查昵称的字典，用来添加移除监听对象 关于接口来自易姐的 bilibili-API-collect ，非常感谢 ta函数封装由我实现，弄得一坨 萌属性抽取插件名：MoeAttriLottery 之前写好这个插件的时候还有些沾沾自喜，然后看了别人家的机器人才发现，这其实是几年前就玩过时了的东西w果然是你能想得到的东西，别人早就想到了 数据源由我整理自萌娘百科-萌属性 运行逻辑非常简单的带权重的随机抽取而已，一天仅能抽一次 拥有权重机制，比如我能把年龄属性中的“萝莉”调到10，其他全为1😋 拥有主副属性机制，当抽到的主属性在副属性中有键时，会再抽一个副属性出来比如抽到了渐变色瞳，还可以再抽到一个红-&gt;蓝渐变的细分支 emm 大概就是这样，以后应该还会继续维护 Mirai 酱的，有种养女儿的快感 😋","categories":[{"name":"Program","slug":"Program","permalink":"https://ningmenglemon.github.io/categories/Program/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://ningmenglemon.github.io/tags/Python/"},{"name":"onebot","slug":"onebot","permalink":"https://ningmenglemon.github.io/tags/onebot/"},{"name":"QQ","slug":"QQ","permalink":"https://ningmenglemon.github.io/tags/QQ/"},{"name":"shamrock","slug":"shamrock","permalink":"https://ningmenglemon.github.io/tags/shamrock/"}]},{"title":"尝试详细介绍一下我的 BiliTools","slug":"Try-to-introduce-my-BiliTools","date":"2023-12-29T07:36:00.000Z","updated":"2024-02-08T07:15:10.818Z","comments":true,"path":"2023/12/29/Try-to-introduce-my-BiliTools/","permalink":"https://ningmenglemon.github.io/2023/12/29/Try-to-introduce-my-BiliTools/","excerpt":"","text":"想要介绍一下陪了自己两年多的项目 , 顺便练一下 markdown 语法 阅前提示: 以下内容的措辞可能令人费解, 因为咱在表达方面并没有什么天赋 以下内容不一定正确或者符合规范, 如果有错误欢迎提出w IntroBiliTools 是我在 2021 年 5 月左右使用 Python 编写的一个用于下载 B 站的各种资源的程序 项目地址 关于版本号因为有前身在, 所以版本号直接从 2 开始又因为咱的脑子可能有点抽风, 版本号目前都是 v.2.0.0_Dev{实际更新版本数} 这个样子w目前更新到了 Dev17 的说, 以下内容都是适用于该版本的 关于前身前身是由我编写的 BiliDownloader, 其实就是一个 you-get 的 GUI 而已附加了一点针对 B 站的功能, 比如弹幕下载和过滤, 版本号为 1 史山注意首先最初在写这个程序的时候我还是个若至, 像各种语言规范什么的都不知道 你可以在程序中见到: 随处可见的超长单行 刁钻古怪的调用链 (几乎)没有类型标注 稀少的注释与日志 一些不知道在干什么但是删掉就会出 Bug 的代码 各种若至的代码逻辑 各种花里胡哨但又一堆 Bug 的功能 然后到现在我稍微懂了那么一点语言规范, 但是先前拉的史已经不好收拾了 有的时候甚至都不想再继续写, 想 remake 一个新程序出来了 这个程序伴随着我的进步, 我的程序水平也在逐渐提升（吗？） 所以还是蛮有纪念意义的, 对吧 感谢Bilibili-API-collect danmaku2ass Quick Overview文件结构截至 Dev17 的文件结构如下 12345678910111213141516171819202122232425262728293031BiliTools├─ bilitools.py # 主程序├─ basic_window.py # 提供了(几乎)所有窗口的基类├─ bezier_curve.py # (未使用)用于画贝塞尔曲线的一些基本操作├─ configuration.py # 一些与配置相关的数据与操作├─ custom_widgets.py # 一些自定义的 tk 组件├─ danmaku2ass.py # 修改过的 danmaku2ass├─ ffdriver.py # 用于调用 ffmpeg 的操作├─ imglib.py # 图标们 (以 base64 方式编码的 png)├─ textlib.py # Tips 和 About 文本├─ videoshot_handler.py # 提供了用于处理视频快照的一个类└─ biliapis # 封装了一些 B 站的 API, 大多取自 bilibili-api-collect ├─ __init__.py # 用于统领起这个 API 库, 定义了一些杂七杂八的操作 ├─ requester.py # 用于请求的模块 ├─ error.py # 定义了错误类 ├─ bilicodes.py # 各种常用的标识码 ├─ wbi.py # WBI 鉴权 ├─ article.py # 专栏相关 ├─ audio.py # 音频相关 ├─ comment.py # 评论相关 ├─ danmaku.py # 弹幕相关 ├─ dynamic.py # 动态相关 ├─ live.py # 直播相关 ├─ login.py # 登录相关 ├─ manga.py # 漫画相关 ├─ media.py # 影视与番剧相关 ├─ stream.py # 媒体流相关 ├─ subtitle.py # 字幕相关 ├─ user.py # 用户相关 ├─ video.py # 视频相关 └─ other.py # 其他 API 依赖12345678tkinter # GUI 库, Python 应该会自带pillow # 用于图像处理qrcode # 用于生成二维码beautifulsoup4 # 用于处理 HTML 和 XMLbrotli # 用于解压数据lxml # bs4 的依赖colorama # 用于控制台着色pycryptodome # 用于计算 CorrespondPath ffmpeg - 通过管道进行调用, 安装即可 Go ♂ Deeper各个类间的继承关系点击展开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647object├─ DownloadManager├─ Window│ ├─ MainWindow│ ├─ BatchWindow│ ├─ InputWindow│ ├─ ConfigWindow│ ├─ AudioWindow│ ├─ CommonVideoWindow│ ├─ CollectWindow│ ├─ LoginWindow│ ├─ PbpShower│ ├─ PartsChooser│ ├─ BlackroomWindow│ ├─ BangumiWindow│ ├─ MangaViewer_Rolling (未完工)│ ├─ MangaViewer_PageTurning (未完工)│ ├─ SearchWindow│ ├─ PlotShower│ ├─ VideoShotViewer│ ├─ ArticleWindow (未完工)│ ├─ ToviewWindow (未完工)│ └─ Thread_with_gui├─ ToolTip├─ _CustomMsgbox└─ VideoShotHandlertk.Frame└─ VerticalScrolledFrame ├─ _CommonVideoSearchShower └─ _MediaSearchShowerttk.Button└─ ImageButtontk.Label└─ ImageLabeltk.Toplevel└─ _TipWindowException└─ BiliErrorthreading.Thread└─ _DownloadThread 多线程的处理就像其他基于 tk 的应用程序一样, 此程序也以主线程为主 为了处理那些耗时的任务, 自然是需要用到子线程的, 但是子线程没办法直接修改 tk 窗口中的对象, 否则就会导致thread not in mainloop错误 于是我在basic_window.py中的Window基类中定义了一个task_queue成员. 这是一个队列, 子线程可以向其中放入无参的函数对象, 而这些函数对象会被位于主线程中的由Tk.after()驱动的一个自动循环执行的函数listen_task自动取出并在主线程中执行. 此时这个函数是在主线程中被执行的, 就可以直接修改窗口中的对象了. 像这样, 耗时的任务就可以在子线程中执行完毕, 然后把数据装在上述的函数中发送给主线程, 再由这个函数填充到窗口中 (填充的过程其实耗时很少) 这个基类的多线程控制部分 1234567891011121314151617181920212223242526272829class Window(object): # 程序中所有常规窗口的父类 def __init__(self, ..., toplevel=False, ..., master=None): self.task_queue = queue.Queue() # 此队列用于储存来自子线程的无参函数对象 if toplevel or master: self.window = tk.Toplevel(master=master) else: self.window = tk.Tk() ... self.listen_task() def listen_task(self): if not self.task_queue.empty(): func = self.task_queue.get_nowait() try: func() except Exception as e: logging.error(&#x27;Task Listener Caught an Error: &#x27;+str(e)) #raise traceback_info = traceback.format_exc() # print(traceback_info) else: pass #logging.debug(&quot;Call func: &quot;+str(func)) if self.task_queue.empty(): self.window.after(10,self.listen_task) else: self.window.after(1,self.listen_task) ... ...是被省略的部分 我通过这种方式来进行多线程协调. 听上去还是蛮巧妙的? 但是, 把这个方法写在基类中就意味着, 每个窗口创建时都会附带一个队列和一个反复执行的函数. 我不清楚别人是不是这么做的, 反正我当时就这么写了w.现在我对这个做法其实不是很满意, 因为我认为这可能消耗了额外的资源 , 多少有些强迫症了 网络请求的封装比较让人难绷的是, 我以前把负责网络请求的模块requester直接放在了biliapis模块中, 我现在觉得这个层次结构不算合理.这也就是说, 要想把biliapis模块用到别的项目中, 底下的requester也会被 copy 一份, 而那个别的项目中可能已经有了别的网络请求模块, 就会造成冗余…然后requester中封装的get与post还对返回的流对象做了处理, 把请求过程中创建的req.Request对象嗯塞了进去, 这是为了方便login模块中对 cookies 的操作. 但也进一步导致了可移植性的下降. 搓程序时候的趣事(?) ChatGPT 一开始说用urllib打开的流中会有request这个成员, 但是其实使用 opener 打开的流中并没有, 当时跟 GPT 杠了挺久, 然后 GPT 改口了ww GPT 最终的答复是: opener.open()方法返回的HTTPResponse对象可能不会附带request属性。这是因为opener.open()方法是一个高级接口，它隐藏了底层的请求细节，不直接暴露Request对象。 以get方法为例, 它的代码如下 1234567@auto_retry(retry_time)def get(url, headers=fake_headers_get): req = request.Request(url, headers=headers) response = opener.open(req, None, timeout=timeout) response.request = req # 强行塞入 request logging.debug(&#x27;Get: &#x27;+url) return response 我猜你想吐槽... 啊你这个请求怎么没有用with啊这个函数怎么直接就把流对象传回去了啊 emm来看其他部分是怎么用这个函数的: 1234567def get_content_bytes(url, headers=fake_headers_get, update_cookie=True): # 取名有问题, 请自动忽略 content 这个词 with get(url, headers=headers) as response: if cookies and update_cookie: cookies.make_cookies(response, response.request) return read_and_decode_data(response) # 取名也有问题, decode 应该改成 decompress 我其实不是很确定用自动重试装饰器来修饰这个函数是不是正确的选择 总之就是很不满意 (叉腰) 多窗口之间的协作首先需要提醒的是, 下文提到的Window(定义在basic_window.py中)继承自object, tk.Tk或者tk.Toplevel对象则被存放在Window.window处 很令人费解是吧? 我也想问问以前的我为什么要这么写 我一般会在窗口类(一般继承自Window)的__init__()方法的末尾加上self.window.wait_window(self.window)来使外界在执行实例化窗口类的操作时停在这一步, 直到窗口被释放 (self.window.destroy()被执行)官方的模块 tk.messagebox 和 tk.filedialog 中的操作也有类似的逻辑 当时的我在Window类中直接把上面那个”停下”的操作封装成了self.mainloop()这个方法, 极具迷惑性.注意与下文提到的mainloop做区别.越写就越想穿越回去抽自己几个大嘴巴子 对于大部分不需要在打开窗口的同时打开另一个窗口的窗口是这样.至于为什么不用Tk.mainloop()来等待窗口, 是因为我发现如果这样做的话, 关闭窗口时会产生一些莫名其妙的问题按照我的理解, Tk.mainloop()会使整个 tk 的事件循环阻塞主线程; 如果通过Tk.destroy()将其打破, tk 会认为整个程序应该结束了, 但其实没有, 这只是一个窗口关闭了而已. 于是我的整个程序里一个Tk.mainloop()都没用过w 而除了下载窗口外的所有子窗口(Toplevel)的父窗口都是主窗口(Tk), 当把主窗口关掉的时候其余窗口就会被自动地关闭.至于下载窗口, 它拥有特殊的内部逻辑, 并没有使用等待窗口这一机制. 下载器的内部逻辑这一部分最初于 2021 年 11 月左右完成 (根据写的日志来看)当时这部分是在自习课上想出来的, 笔记本应该还能找到, 但是放在家里了w 这一部分是线程安全问题的重灾区.中途曾尝试修复过一次, 给涉及到多线程操作的几个列表添加了线程锁. 但是偏偏漏掉了最核心的用于存储原始数据的列表和另外三个用于存放任务状态的列表.我最终发现这个遗留问题的时候已经为时已晚. 各个线程锁在之前尝试修复的时候搅成了一坨, 就连继续往上拉史都做不到了, 哪怕只加一个线程锁都会在莫名其妙的地方锁死.当然如果花时间的话其实还是可以修的, 需要把之前修的地方推掉重来 显示机制并不是通过修改窗口属性将构建好的窗口显示或隐藏, 而是到了需要显示的时候才开始构建 当 用于接受下载任务的task_receiver()被调用 且 这个函数运行于主线程中 时, show()方法会被自动调用show()方法会执行构建 GUI 的代码, 而hide()方法则会直接销毁整个窗口由于涉及到 GUI 操作, 上述两个方法都必须在主线程中运行 窗口中显示的的任务信息存储在table_display_list这个多维列表中, 每次刷新显示的信息时auto_refresh_table这个方法会将它的内容展示到 GUI 中 auto_refresh_table也是借助Tk.after()来进行自动循环的 下载器刷新 GUI 的流程: 刷新任务列表 如果任务数没有变动, 那么直接修改对应项的值 如果任务数有变动: 先记录哪些项被选中了 然后删除列表框中的所有项 将新的信息填充进去 复现先前选中的项 更新统计信息 准备下一次自动刷新 数据存储与任务管理最核心的内容是data_objs这个成员, 它存储着传入task_receiver的原始数据下载的各个步骤都会读取 有三个索引列表与它相关 failed_indexes running_indexes done_indexes 存放的内容是任务对应的数据在data_objs中的索引也是在table_display_list中的索引 我认为下载器中的最关键的一个量就是这个索引在特化的任务函数中第一个显式参数就是index, 说的就是这个索引 感觉逼逼叨叨这么多还不如放张图, 等我… 试着用了 mermaid 语法 flowchart TB F(下载管理器实例化) -- 启动 --> auto_thread_starter subgraph auto_thread_starter direction TB b{检查 task_queue} b -- 有任务 --> c[将任务取出, 作为子线程开始运行] b -- 无任务 --> b c --> b end c -- 启动 --> task_itself subgraph task_itself direction TB g[将参数中的 index 放入 running_indexes] g --> h[任务计数器+1] h --> i[进行任务内容] i --> j[将 index 从 running_indexes 中移除] j --> k{任务是否成功} k -- 是 --> l[将 index 放入 done_indexes] k -- 否 --> m[将 index 放入 failed_indexes] l --> n(任务计数器-1) m --> n end 如果要添加任务, 则遵循下面的流程: 另一个流程图 flowchart TB direction TB A(添加任务) --> B[获取到下载所需的数据] B --> C[将任务数据放入 data_objs] C --> D[ 将对应的任务函数和任务在 data_objs 中的索引和数据包装成 lambda 然后放入 task_queue ] D --> E[ 在 table_display_list 中创建位置 任务在两个列表中的索引保持一致 ] 下载进度的保存与读取保存程序会遍历整个data_objs, 从中筛选出还没有成功的任务组成一个列表然后将这个列表作为一个临时字典的objs键对应的值table_display_list中对应的项也会被组成列表, 作为这个临时字典的displaylist键对应的值最后程序会将这个字典保存为 json 文件 上述操作被封装为了save_progress这个方法这个方法在每次有任务开始或结束的时候都会被调用 读取首先程序会读取保存的 json 文件, 然后遍历其中的objs列表, 按照与task_receiver中类似的方法逐个添加任务在这个过程中, 除了任务状态文本会被改成待处理外, 其余内容将会与保存前保持一致 上述操作被封装为了load_progress这个方法这个方法在程序启动的时候经过用户确认后会被调用 Tkinter 中的滚动页面的实现我最开始定义了一个继承自tk.Frame的滚动框架VerticalScrolledFrame 在用它展示条漫时我发现它的最大滚动范围在 31000px 左右, 这可能是canvas的极限 层次结构是:frame &gt; canvas &gt; frame &gt; 页面元素 flowchart LR subgraph top_frame subgraph canvas subgraph bottom_frame page_content end end scrollbar[ S c r o l l b a r] end emm大概长这样, 可能有些夸张了 缺点是需要手动给页面元素绑定鼠标滚动等事件纵向滚动条用于控制页面的滚动, 实质上是在控制canvas中的里层frame的上下移动 这个框架被设计成宽度由内容物的宽度决定, 高度由用户定义被用在了SearchWindow的Notebook的单个分页中 如果需要左右滚动的话也同理了加上一些自动调用的代码应该就能实现像橱窗那样的循环展示效果 (虽然我没亲自写过) 互动视频剧情图展示器的实现整个剧情图的展示基于tk.Canvas画布, 在画布右侧和下方分别加上了纵向滚动条和横向滚动条 最核心的内容是self.plots与self.explored_plot_idsself.plots是一个装着(装着字典的列表)的列表, 分层存储着请求到的原始数据节点们组成类似于有向图的结构, 像下面这样一开始我其实是把它当作树来处理的 flowchart TB subgraph self.plots subgraph layer_1 plot_1 end subgraph layer_2 plot_2 plot_3 plot_4 end subgraph layer_3 plot_5 plot_6 end end plot_1 --> plot_2 plot_1 --> plot_3 plot_1 --> plot_4 plot_2 --> plot_5 plot_2 --> plot_6 plot_3 --> plot_5 plot_4 --> plot_5 plot_6 --> plot_2 我超这个mermaid的牛魔绘图啊分层是为了更有层次地绘图 各个节点之间的连接由每个节点数据中包含的多个jump_edge_id确定 为了方便画图, 引入了self.explored_plot_ids, self.plot_coorsself.explored_plot_ids是一个字典, 以节点id: (节点所在的层的索引, 节点在层中的索引)的形式存储节点id到节点数据的映射self.plot_coors是一个字典, 以节点id: (节点在画布中的x坐标, y坐标, 节点块的宽, 节点块的高)的形式存储节点id到节点块在画布中的位置的映射 为了方便下载, 引入了self.cid_map和self.avid_map这两个字典它们分别存储节点id到cid的映射和cid到avid的映射 节点的探索互动视频有两个重要的id, 剧情图idgraph_id 和 节点idedge_id剧情图id代表这个互动视频, 节点id代表它的节点 剧情图id可以通过向这个接口提交互动视频的cid和(avid或bvid)得到 每个节点id都有对应的cid, 配合互动视频的bvid或avid可以取到视频的流初始节点的cid就是这个互动视频的cid其实互动视频的节点就是另一种形式的视频分P 对接口的节点id参数传入0就可以获得初始节点的数据 借由初始节点的数据, 可以得到它可能跳转到的节点们的id再请求这些节点id的数据, 获得它们可能跳转到的节点们的id就这么一直下去, 直到不再有新的节点id出现 如果一个节点没有跳转到的节点, 就说明它是终止节点 将每一轮上述操作获得的数据按轮分层 (初始节点单独一层), 就完成了节点探索的操作 节点的绘制先看效果() 目标视频: 电棍家中的惨案 起始节点被涂成淡红色, 终止节点被涂成淡绿色 遍历整个self.plots, 为每个节点绘制块, 然后为每个节点绘制跳转箭头 如果节点跳转到的是下一层的节点, 那么直接连接即可 原本想用贝塞尔曲线来连接的, 然后寄了 否则则将箭头拉到画布顶部或底部, 绕到目标块所在层的后面进行连接(跳连) 设置了一些偏移值来确保箭头的线不会重合.(但是对于一些关系复杂的互动视频, 上述策略会造成跳连的箭头太多, 导致绘图非常混乱, 完全没法读) 翻车了 目标视频: 收养澄闪 视频做得太好导致的 以后可能会做一个生成mermaid流程图的功能? (画饼ing) 总之这玩意真就图一乐 交互点击我想实现当点击一个节点块的时候, 打开侧边栏并在其中展示这个节点的信息这个交互逻辑 首先来实现点击绘图对象罢.tk.Canvas其实是可以为其中的绘图对象绑定点击事件的, 但我当时不知道w我给整个 canvas 绑定了一个点击事件, 根据坐标来判断被点击的节点块 所谓的侧边栏, 是另一个隐藏在右边的框架当它要显示的时候, canvas 的宽度会减小侧边栏的宽度那么多, 然后侧边栏框架出现 值得注意的是, 我已经发现了超出 canvas 范围的的强制滚动会使我的点击事件错位这个问题, 我会在后续将它修复 简称: 下次一定 拖动写到这里的时候发现我之前写的拖动操作寄了 那么今天的内容就到这里了让我们下次再见 Defects线程安全问题这个问题在 下载器的内部逻辑 这部分有提到 大概就是, 如果有多个线程同时操作一个线程不安全的对象, 就可能会出问题Python 中的字典是线程安全的, 但是列表不是 为了避免这个问题, 可以: 给操作对象加上线程锁, 使同一时间只能有一个线程访问它 换用线程安全的对象来存储信息 上文提到的修复, 便是给对象加锁结果加成了一坨 (恼) 默认参数评估问题这个问题潜伏了很久, 直到在我使用custom_widgets中的run_with_gui这个函数的时候才被发现 发现的过程 程序第一次调用run_with_gui时, is_progress_hook_available这个参数被传入了True.这会使这个函数传入的func参数(这是一个函数)在后续的过程中被额外传入一个叫做progress_hook的字典, func函数可以通过修改这个字典来汇报任务的进度 问题就在于额外传入这个操作上.在老版本的程序中, 程序在准备阶段会直接修改先前传入的kwargs, 以便后续方便地使用func(**kwargs)来传入参数.而我将kwargs的默认参数设定为了&#123;&#125;, 而不是None. 第二次调用的时候到了, 这次is_progress_hook_available这个参数被传入了默认的False(这倒不是问题的所在), 按照程序的设计, kwargs不会被修改. 比较巧合的是, 第一次传入的函数只有progress_hook这一个参数, 而第二次的函数则是无参的, 两次调用的kwargs这个参数都没有被指定.这就导致了后文所说的默认参数评估的问题. TypeError: self.func() got an unexpected keyword argument ‘progress_hook’ 解释器: Aughhhhhhhhh 虽然我自主地修复了这个问题, 并且知道它导致的问题是前一次调用影响到了后一次, 但以我的水平无法解释它的成因 有请: GPT 先生! 在Python中，函数的默认参数如果设置为字典（或其他可变数据类型，如列表、集合等），会有一个潜在的陷阱：如果默认参数在函数内部被修改了，那么这个修改会在未来的函数调用中持续存在。这是因为默认参数只会在函数定义时被评估一次，不是每次调用时都评估。这意味着，如果你修改了默认参数的内容，那么下一次调用函数时，默认参数的值不再是定义函数时指定的原始值。这个行为对于不可变的默认值（例如None、整数、字符串等）通常不会导致问题，因为它们不会被函数调用所改变。然而，对于可变的默认值（例如字典、列表等），这种行为可能导致意外的副作用，因为如果函数内部修改了这些可变对象，这些修改会影响到下一次函数调用时这些默认参数的状态。 ChatGPT 举的例子 以一个列表作为默认参数的函数为例，来展示这个评估过程： 123def append_to_list(value, my_list=[]): # 默认参数在这里被评估一次 my_list.append(value) return my_list 在这个例子中，my_list=[] 是一个默认参数。这个默认参数的列表对象在函数定义时创建，并且只创建一次。如果你在函数内部修改了 my_list，比如通过调用 append_to_list 函数，那么你实际上是在修改这个单一的、在函数定义时创建的列表对象。这样，下一次调用 append_to_list 时，你将看到上一次调用的结果仍然保留在列表中，因为它是同一个列表对象。 为了避免这种情况，你应该使用一个不可变的默认值，比如 None，然后在函数内部检查它，并在需要时创建一个新的列表： 12345def append_to_list(value, my_list=None): if my_list is None: my_list = [] # 在这里为每次调用创建一个新的列表 my_list.append(value) return my_list 在这个修正后的版本中，每次调用 append_to_list 时，如果没有提供 my_list 参数，就会创建一个新的空列表。这样，每次函数调用都是独立的，不会有意外的共享状态。 BiliTools 中的很多函数都被我像这样写了, 比如这个: 12def _video_download_thread(self, ..., subtitle_regulation=config[&#x27;download&#x27;][&#x27;video&#x27;][&#x27;subtitle_lang_regulation&#x27;], ...): ... 这些问题目前还没有得到修复…绝对不是因为我忘了! 我回头就去修! 其他问题 未完待续…","categories":[{"name":"Program","slug":"Program","permalink":"https://ningmenglemon.github.io/categories/Program/"}],"tags":[{"name":"Bilibili","slug":"Bilibili","permalink":"https://ningmenglemon.github.io/tags/Bilibili/"},{"name":"Python","slug":"Python","permalink":"https://ningmenglemon.github.io/tags/Python/"},{"name":"Tkinter","slug":"Tkinter","permalink":"https://ningmenglemon.github.io/tags/Tkinter/"}]},{"title":"Just a test","slug":"Just-a-test","date":"2023-12-27T11:11:44.000Z","updated":"2023-12-29T07:32:33.990Z","comments":true,"path":"2023/12/27/Just-a-test/","permalink":"https://ningmenglemon.github.io/2023/12/27/Just-a-test/","excerpt":"","text":"Hello bro, this is just a test page. If set properly, a sticker will be displayed below.","categories":[{"name":"Test","slug":"Test","permalink":"https://ningmenglemon.github.io/categories/Test/"}],"tags":[{"name":"Test","slug":"Test","permalink":"https://ningmenglemon.github.io/tags/Test/"},{"name":"Cheshire Cat","slug":"Cheshire-Cat","permalink":"https://ningmenglemon.github.io/tags/Cheshire-Cat/"}]}],"categories":[{"name":"Program","slug":"Program","permalink":"https://ningmenglemon.github.io/categories/Program/"},{"name":"Test","slug":"Test","permalink":"https://ningmenglemon.github.io/categories/Test/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://ningmenglemon.github.io/tags/Python/"},{"name":"onebot","slug":"onebot","permalink":"https://ningmenglemon.github.io/tags/onebot/"},{"name":"QQ","slug":"QQ","permalink":"https://ningmenglemon.github.io/tags/QQ/"},{"name":"shamrock","slug":"shamrock","permalink":"https://ningmenglemon.github.io/tags/shamrock/"},{"name":"Bilibili","slug":"Bilibili","permalink":"https://ningmenglemon.github.io/tags/Bilibili/"},{"name":"Tkinter","slug":"Tkinter","permalink":"https://ningmenglemon.github.io/tags/Tkinter/"},{"name":"Test","slug":"Test","permalink":"https://ningmenglemon.github.io/tags/Test/"},{"name":"Cheshire Cat","slug":"Cheshire-Cat","permalink":"https://ningmenglemon.github.io/tags/Cheshire-Cat/"}]}